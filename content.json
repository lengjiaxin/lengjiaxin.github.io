[{"title":"linux命令介绍","date":"2017-10-14T16:00:00.000Z","path":"2017/10/15/2170-10-15-linux/","text":"使用linux快速复制 斜杠回到根目录 TAB上下键快捷选择","tags":[{"name":"linux","slug":"linux","permalink":"//litten.me/tags/linux/"}]},{"title":"Git Hub Commit","date":"2017-08-17T14:29:38.666Z","path":"2017/08/17/2017-08-17-commit/","text":"1、打开本地git命令窗口或者cmd命令窗口，cd到你存放项目的根目录下，并执行一下命令行： git clone 仓库地址(上面一步复制出来的地址)，如下图，是我复制我创建的仓库地址： 2、打开项目文件夹，会发现刚才在github里面新建的文件都存在本地了， 3、将要上传的文件拷贝到这个目录下，拷贝完成后，再执行下命令git status，看git是否获取到文件的更改，如图： 4、再执行命令git add –all,将所有文件都添加到仓库中，如果想添加某一个文件，则将后面的–all换成你要提交的文件名即可。 5、然后还需要将增加的文件commit到仓库里去，执行命令git commmit -m “注释语句”，如图： 6、此时还没完，还要将commit的代码push到远程分支，由于我们本地只有master分支，所以我们可以直接执行命令git push，如图： 会让你输入用户名和密码，你输入你github登录的用户名和密码即可。","tags":[{"name":"github","slug":"github","permalink":"//litten.me/tags/github/"}]},{"title":"Java ConcurrentHashMap 缓存","date":"2017-07-18T08:20:04.988Z","path":"2017/07/18/2017-07-18-cache/","text":"ConcurrentHashMap 缓存在项目实际开发中有时候固定不变的数据，大量请求数据库增加IO。我们就可以考虑缓存到内存中定时更新维护就行建议先看看：ConcurrentHashMap 基础类MonitorCache/** * Title: MonitorCache.java&lt;br /&gt; * Description: 实时监控缓存类&lt;br /&gt; * Copyright: Copyright (c) 2017&lt;br /&gt; */ public final class MonitorCache&lt;K, V&gt; { // 缓存Map private ConcurrentHashMap&lt;K, V&gt; cache; // 缓存计数器（用于判断缓存是否被占用） private int cacheCounter; // 更新时间（用于判断缓存中的数据是否更新） private Date updateDate; public MonitorCache() { this.cache = new ConcurrentHashMap&lt;K, V&gt;(); this.cacheCounter = 0; } public Date getUpdateDate() { return updateDate; } public void setUpdateDate(Date updateDate) { this.updateDate = updateDate; } /** * 开启缓存（计数器加1） */ public synchronized void open() { this.cacheCounter++; } /** * 关闭缓存（计数器减1） */ public synchronized void close() { this.cacheCounter = (this.cacheCounter - 1 &lt; 0) ? 0 : (this.cacheCounter - 1); } /** * 缓存当前是否空闲（未被占用） * * @return */ public boolean isFree() { return (this.cacheCounter == 0); } // 缓存访问校验 private void validate() { if (this.cacheCounter == 0) { throw new RuntimeException(&quot;缓存未打开时禁止访问&quot;); } } /** * 写入缓存数据 * * @param k * @param v */ public void put(K k, V v) { validate(); this.cache.put(k, v); } /** * 读取缓存数据 * * @param k * @return */ public V get(K k) { validate(); V v = this.cache.get(k); return v; } /** * 是否包含键值 * * @param key * @return */ public boolean containsKey(Object key) { validate(); return this.cache.containsKey(key); } /** * 读取所有键值 * * @return */ public Set&lt;K&gt; getAllKeys() { validate(); return this.cache.keySet(); } /** * 清空缓存 */ public void clearCache() { validate(); if (this.cache != null &amp;&amp; !this.cache.isEmpty()) { this.cache.clear(); } } /** * 缓存中存放的数据量 * * @return */ public int size() { validate(); return this.cache.size(); } } 分组类 MonitorCacheGroup/** * Title: MonitorCacheGroup.java&lt;br /&gt; * Description: 实时监控缓存集合类&lt;br /&gt; * Copyright: Copyright (c) 2017&lt;br /&gt; */ public final class MonitorCacheGroup&lt;K, V&gt; { private static final LogWrapper log = new LogWrapper(MonitorCacheGroup.class); // 缓存集合总量 private final static int CACHECOUNT = 5; // 缓存集合 private final List&lt;MonitorCache&lt;K, V&gt;&gt; cacheList; public MonitorCacheGroup() { cacheList = new ArrayList&lt;MonitorCache&lt;K, V&gt;&gt;(CACHECOUNT); MonitorCache&lt;K, V&gt; cache = null; for (int i = 0; i &lt; CACHECOUNT; i++) { cache = new MonitorCache&lt;K, V&gt;(); cacheList.add(cache); } } /** * 更新缓存 * * @param updatedCache */ public void updateCache(MonitorCache&lt;K, V&gt; updatedCache) { for (int i = 0; i &lt; CACHECOUNT; i++) { if (cacheList.get(i).isFree()) { updatedCache.setUpdateDate(new Date()); if (cacheList.get(i).isFree()) { cacheList.remove(i); cacheList.add(i, updatedCache); log.debug(&quot;当前更新缓存序号:&quot; + i); break; } } } } /** * 获取缓存（默认打开缓存） * * @return */ public MonitorCache&lt;K, V&gt; getCache() { int index = 0; // 要返回最近更新过的那份缓存 Date maxDate = cacheList.get(0).getUpdateDate(); for (int i = 1; i &lt; CACHECOUNT; i++) { MonitorCache&lt;K, V&gt; cache = cacheList.get(i); if (!ValidationUtil.isNullOrEmpty(cache) &amp;&amp; !ValidationUtil.isNullOrEmpty(cache.getUpdateDate())) { // 缓存没有数据 if (cache.getUpdateDate().compareTo(maxDate) &gt; 0) { maxDate = cacheList.get(i).getUpdateDate(); index = i; } } } log.debug(&quot;当前获取缓存序号:&quot; + index); cacheList.get(index).open(); return cacheList.get(index); } /** * 关闭缓存 * * @param cache */ public void closeCache(MonitorCache&lt;K, V&gt; cache) { if (cache != null) { cache.close(); } } } 使用缓存示例// 缓存容器 private volatile MonitorCacheGroup&lt;String, List&lt;Integer&gt;&gt; vehicleCacheGroup = new MonitorCacheGroup&lt;String, List&lt;Integer&gt;&gt;(); MonitorCache&lt;String, List&lt;Integer&gt;&gt; vCache = new MonitorCache&lt;String, List&lt;Integer&gt;&gt;(); //打开 vCache.open(); //更新 vehicleCacheGroup.updateCache(vCache); //获取 vCache.get(key);","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"yilia配置CNZZ","date":"2017-06-28T16:00:00.000Z","path":"2017/06/29/2017-06-29-2-yilia/","text":"使用CNZZ数据专家1、修改 themes\\yilia\\layout_partial\\footer.ejs 模板，把如下代码 &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt; 修改为： &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;-- 这里填写入CNZZ得js代码段 --&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt;","tags":[{"name":"yilia","slug":"yilia","permalink":"//litten.me/tags/yilia/"}]},{"title":"yilia配置多说评论","date":"2017-06-28T16:00:00.000Z","path":"2017/06/29/2017-06-29-1-yilia/","text":"使用畅言系统1、修改 themes\\yilia\\layout_partial\\article.ejs 模板，把如下代码 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; 这里还有很多代码 &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 修改为： &lt;% if (!index &amp;&amp; post.comments){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!--高速版，加载速度快，使用前需测试页面的兼容性--&gt; &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.title %&gt;&quot;&gt;&lt;/div&gt; &lt;script&gt; (function(){ var appid = &apos;你的APP ID&apos;, conf = &apos;你的APP KEY&apos;; var doc = document, s = doc.createElement(&apos;script&apos;), h = doc.getElementsByTagName(&apos;head&apos;)[0] || doc.head || doc.documentElement; s.type = &apos;text/javascript&apos;; s.charset = &apos;utf-8&apos;; s.src = &apos;http://assets.changyan.sohu.com/upload/changyan.js?conf=&apos;+ conf +&apos;&amp;appid=&apos; + appid; h.insertBefore(s,h.firstChild); window.SCS_NO_IFRAME = true; })() &lt;/script&gt; &lt;/section&gt; &lt;% } %&gt; 上面的APP ID和APP KEY是在畅言设置中得到。 这里需要注意一点的是：sid=”&lt;%= page.title %&gt;”&gt; 这样的话畅言就可以直接根据对应的文章来识别，使得文章有对应的评论，不会都乱在一起。 2、在每篇文章开头的 front-matter 中添加一句comments: true，然后回到博客根目录执行命令 hexo d -g ，重新生成博客并部署博客，然后刷新，任选一篇文章进入下拉，会发现评论功能可以使用了。 修改 BUG但是，这是你会发现一个 Bug，表情按钮点击不了，原因是被左侧的 div 层覆盖了，回到我们刚才改过的代码，找到 &lt;div id=”SOHUCS” 开头的一串代码。并做如下更改 &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.title %&gt;&quot; style=&quot;padding: 0px 30px 0px 46px;&quot;&gt;&lt;/div&gt; 加入上面这一段样式代码，即可修复。","tags":[{"name":"yilia","slug":"yilia","permalink":"//litten.me/tags/yilia/"}]},{"title":"Javascript 页面飘窗","date":"2017-06-26T16:00:00.000Z","path":"2017/06/27/2017-06-27-8-Javascript/","text":"Javascript设置相对屏幕左右距离&lt;script type=&quot;text/javascript&quot;&gt; var obj; var x = 50,y = 60; var xin = true, yin = true; var step = 1; var delay = 30; function floatAD() { var L=T=0; var R= (document.documentElement.clientWidth || document.body.clientWidth)-obj.offsetWidth; var B = (document.documentElement.clientHeight || document.body.clientHeight)-obj.offsetHeight; obj.style.left = x + (document.documentElement.scrollLeft || document.body.scrollLeft) + &apos;px&apos;; obj.style.top = y + (document.documentElement.scrollTop || document.body.scrollTop) + &apos;px&apos;; x = x + step*(xin?1:-1); if (x &lt; L) { xin = true; x = L} if (x &gt; R){ xin = false; x = R} y = y + step*(yin?1:-1); if (y &lt; T) { yin = true; y = T } if (y &gt; B) { yin = false; y = B } } function loadTest(){ obj = document.getElementById(&quot;pc&quot;); if(obj!=null){ var itl= setInterval(&quot;floatAD()&quot;, delay); obj.onmouseover=function(){clearInterval(itl)}; obj.onmouseout=function(){itl=setInterval(&quot;floatAD()&quot;, delay)}; } } &lt;/script&gt; HTML设置加载onload=&quot;loadTest();&quot;//页面初始化加载 &lt;div id=&quot;pc&quot; style=&quot;Z-INDEX: 1000; POSITION: absolute&quot;&gt;&lt;A href=&quot;www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;IMG src=&quot;images/cypc.png&quot; border=0 width=&quot;280&quot;/&gt;&lt;/A&gt;&lt;/div&gt;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"//litten.me/tags/Javascript/"}]},{"title":"druid连接池监控配置","date":"2017-06-26T16:00:00.000Z","path":"2017/06/27/2017-06-27-9-Mybatis/","text":"Maven添加jar包&lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.2.26&lt;/version&gt; &lt;/dependency&gt; 数据库连接池配置&lt;!-- druid driverClassName属性可以不用配置能自动识别，能自动从连接字符串中获取 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;50&quot; /&gt; 配置Druid过滤器web.xml &lt;!-- 添加druid监控 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 允许清空统计数据 --&gt; &lt;param-name&gt;resetEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 用户名 --&gt; &lt;param-name&gt;loginUsername&lt;/param-name&gt; &lt;param-value&gt;druid&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 密码 --&gt; &lt;param-name&gt;loginPassword&lt;/param-name&gt; &lt;param-value&gt;druid&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 添加Web应用等监控 session监控--&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;profileEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalCookieName&lt;/param-name&gt; &lt;param-value&gt;USER_COOKIE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalSessionName&lt;/param-name&gt; &lt;param-value&gt;USER_SESSION&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; druld配置spring监听过滤&lt;!-- druld配置spring 监听 --&gt; &lt;bean id=&quot;druid-stat-interceptor&quot; class=&quot;com.alibaba.druid.support.spring.stat.DruidStatInterceptor&quot; /&gt; &lt;bean id=&quot;druid-stat-pointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;patterns&quot;&gt; &lt;list&gt; &lt;value&gt;com.*.service.*&lt;/value&gt; &lt;value&gt;com.*.dao.*&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;druid-stat-interceptor&quot; pointcut-ref=&quot;druid-stat-pointcut&quot; /&gt; &lt;/aop:config&gt; 访问地址http://ip:port/project/druid/index.html","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"//litten.me/tags/Mybatis/"}]},{"title":"GitHubBlog绑定域名","date":"2017-06-25T15:20:00.000Z","path":"2017/06/25/2017-06-25-6-Blog/","text":"GitHub Blog 绑定域名1、ping你的http://github.io域名，得到一个IP； 2、修改你的域名解析记录，添加一个A记录，用得到的IP； 3、登录http://github.com&gt;进入项目&gt;Settings&gt;Custom domain&gt;输入你的域名&gt;Save； 4、在博客source文件夹下新建CNAME文件，填入域名；","tags":[{"name":"github","slug":"github","permalink":"//litten.me/tags/github/"}]},{"title":"JAVA GC 简单总结","date":"2017-06-24T16:00:00.000Z","path":"2017/06/25/2017-06-25-7-Java/","text":"GC分代GC的英文全拼是Garbage Collection，意思是垃圾收集。 Java 将堆内存分为三代来管理： 年轻代 (Young Generation) 年老代 (Old Generation) 永久代 (Perm Generation) 年轻代：又分为Eden、From和To，其中From和To又统称为Survivor Spaces（幸存区）。年轻代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例，使用–XX:NewRatio来指定新生代和年老代的大小比例。 年老代：用来存放多次垃圾回收依然存活的对象。 永久代：来存放方法区。可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。 正常情况下，一个对象从创建到销毁，应该是从Eden，然后到Survivor Spaces（幸存区），再到Old Generation（年老代），最后在某次GC下消失。也可能一个对象直接在Eden里死掉，也可能一直在Old Generation（年老代）存活。 GC种类Java GC分为两类： Minar GC FULL GC Major GC Minar GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。 Major GC：是清理老年代。 FULL GC：是清理整个堆空间—包括年轻代和老年代。 GC的时候，会暂停全世界(stop-the-world)，意思是停止所有的应用线程，所以要避免不必要的GC已提高性能。 GC日志-XX:+PrintGCDetails打印日志详情。 -XX:+PrintGCTimeStamps打印时间戳。 -Xloggc输出GC日志到文件。","tags":[{"name":"java","slug":"java","permalink":"//litten.me/tags/java/"}]},{"title":"Mybatis 执行速度监听","date":"2017-06-15T15:23:00.000Z","path":"2017/06/15/2017-06-15-4-Mybatis/","text":"Mybatis 添加执行sql时间监控在Mybatis配置文件中添加执行监控 &lt;!-- 数据库会话工厂 --&gt; &lt;bean id=&quot;sqlSessionFactoryDefault&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceDefault&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean id=&quot;sqlStatementInterceptor&quot; class=&quot;com.lan.console.common.SqlStatementInterceptor&quot;/&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 创建监听类:&nbsp;SqlStatementInterceptor @Intercepts(value = { @Signature(type = Executor.class, method = &quot;update&quot;, args = { MappedStatement.class, Object.class }), @Signature(type = Executor.class, method = &quot;query&quot;, args = { MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class }), @Signature(type = Executor.class, method = &quot;query&quot;, args = { MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class }) }) public class SqlStatementInterceptor implements Interceptor { private static Logger logger = LoggerFactory.getLogger(SqlStatementInterceptor.class); @SuppressWarnings(&quot;unused&quot;) private Properties properties; @Override public Object intercept(Invocation arg0) throws Throwable { MappedStatement mappedStatement = (MappedStatement) arg0.getArgs()[0]; String sqlId = mappedStatement.getId(); Object returnValue; long start = System.currentTimeMillis(); returnValue = arg0.proceed(); long end = System.currentTimeMillis(); long time = end - start; StringBuilder str = new StringBuilder(100); str.append(sqlId); str.append(&quot;: &quot;); str.append(&quot;cost time &quot;); str.append(time); str.append(&quot; ms.&quot;); String sqlInfo = str.toString(); logger.debug(sqlInfo); return returnValue; } @Override public Object plugin(Object arg0) { return Plugin.wrap(arg0, this); } @Override public void setProperties(Properties arg0) { this.properties = arg0; } }","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"//litten.me/tags/Mybatis/"}]},{"title":"Java 字符串操作","date":"2017-05-25T15:23:00.000Z","path":"2017/05/25/2017-05-25-5-Java/","text":"Java 6以后就不再需要StringBuilder拼接字符串 Java基础篇一 在Java中，字符串对象是不可变的，意思是它一旦创建，你就无法再改变它。所以在我们拼接字符串的时候，创建了一个新的字符串，旧的被垃圾回收器所标记。如果我们处理上百万的字符串，然后，我们就会生成百万的额外字符串被垃圾回收器处理。 虚拟机底层在拼接字符串时执行了众多操作。拼接字符串最直接的点操作(dot operator)就是String#concat(String)操作 public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);}public static char[] copyOf(char[] original, int newLength) { char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;}void getChars(char dst[], int dstBegin) { System.arraycopy(value, 0, dst, dstBegin, value.length);} Sevlet绑定Spring bean SpringBeanAutowiringSupport.processInjectionBasedOnServletContext(this,cfg.getServletContext());//初始化Spring public static void processInjectionBasedOnServletContext(Object target, ServletContext servletContext) { Assert.notNull(target, “Target object must not be null”); WebApplicationContext cc = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); AutowiredAnnotationBeanPostProcessor bpp = new AutowiredAnnotationBeanPostProcessor(); bpp.setBeanFactory(cc.getAutowireCapableBeanFactory());bpp.processInjection(target);}","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"2017五一醒悟","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-3-LiftTime/","text":"这个五一回家休息三天,早上自然醒晚上随便玩，当一个人从繁忙中变得比较悠闲时，反而找不到北这也许是大家都有的经历吧，从今天开始我要每天进步一点为以后的生活增添资本，当我回忆自己上班已经4年余时，连我自己都不敢相信这就是事实，当我看到身边的同行的人都拥有他们自己想要的生活时，我都没自信自己这几年到底是干了神马也许我就是一个碌碌无为得人吧，但是在我心里面无时无刻的想要改变自己想自己变得优秀变得强大我想要的生活需要自己去争取,努力每一天都有收获我以后幸福生活添砖加瓦,每天让自己写一篇技术博客 学习基础原理，学习源码精神，找机会自己在git上开源一个项目 坚持每天写一篇博客总结一天收获 学习身边优秀的技能，把好的习惯养成 坚持锻炼身体，有好的基础去学习，健康的资本","tags":[{"name":"生活","slug":"生活","permalink":"//litten.me/tags/生活/"}]},{"title":"Java多线程面试问题","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-2-Java/","text":"1 . 进程和线程之间有什么不同？ 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。 2 . 多线程编程的好处是什么？ 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 3 . 用户线程和守护线程有什么区别？ 当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。 4 . 我们如何创建一个线程？ 有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在Java中创建线程的文章。 5 . 有哪些不同的线程生命周期？ 当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。读这篇文章可以了解更多关于线程生命周期的知识。 6 .可以直接调用Thread类的run()方法么？ 当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。 7 . 如何让正在运行的线程暂停一段时间？ 我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。 8 . 你对线程优先级的理解是什么？ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。 9 . 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 10 . 在多线程中，什么是上下文切换(context-switching)？ 上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 11 . 你如何确保main()方法所在的线程是Java程序最后结束的线程？ 我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于Thread类的joint()方法。 12 .线程之间是如何通信的？ 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\\notify()\\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击这里有更多关于线程wait, notify和notifyAll. 13 .为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？ Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 14 . 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？ 当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 15 . 为什么Thread类的sleep()和yield()方法是静态的？ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 16 .如何确保线程安全？ 在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在线程安全教程中，你可以学到更多。 17 . volatile关键字在Java中有什么作用？ 当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 18 . 同步方法和同步块，哪个是更好的选择？ 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 19 .如何创建守护线程？ 使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 20 . 什么是ThreadLocal? ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 每个线程都会拥有他们自己的Thread变量，它们可以使用get()\\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在ThreadLocal例子这篇文章中你可以看到一个关于ThreadLocal的小程序。 21 . 什么是Thread Group？为什么建议使用它？ ThreadGroup是一个类，它的目的是提供关于线程组的信息。 ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以ThreadGroup是已经过时的，不建议继续使用。Java t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){ @Overridepublic void uncaughtException(Thread t, Throwable e) {System.out.println(“exception occured:”+e.getMessage());} });1 2 3 4 5 6 7 8t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){ @Overridepublic void uncaughtException(Thread t, Throwable e) {System.out.println(“exception occured:”+e.getMessage());} }); 22 . 什么是Java线程转储(Thread Dump)，如何得到它？ 线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。读这篇文档可以了解更多关于产生线程转储的知识。 23 . 什么是死锁(Deadlock)？如何分析和避免死锁？ 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习如何分析死锁。 24 . 什么是Java Timer类？如何创建一个有特定时间间隔的任务？ java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 这里有关于java Timer的例子。 25 . 什么是线程池？如何创建一个Java线程池？ 一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。线程池例子展现了如何创建和使用线程池，或者阅读ScheduledThreadPoolExecutor例子，了解如何创建一个周期任务。 Java并发面试问题 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？ 原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解Java的atomic类。 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 阅读更多关于锁的例子 3. 什么是Executors框架？ Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池，阅读这篇文章可以了解如何使用Executor框架创建一个线程池。 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？ java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。 阅读这篇文章了解如何使用阻塞队列实现生产者-消费者问题。 5. 什么是Callable和Future? Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。 Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 阅读这篇文章了解更多关于Callable，Future的例子。 6. 什么是FutureTask? FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读Java FutureTask例子，学习如何使用它。 7.什么是并发容器的实现？ Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 并发容器支持并发的遍历和并发的更新。 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet，阅读这篇文章了解如何避免ConcurrentModificationException。 8. Executors类是什么？ Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 Executors可以用于方便的创建线程池。","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Hello World","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-1-HelloWorld/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"//litten.me/tags/hexo/"}]}]