[{"title":"点对点营销策略","date":"2019-06-23T05:30:00.000Z","path":"2019/06/23/2019-06-23-Java/","text":"点对点营销策略","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Java知识归纳","date":"2018-08-30T10:00:00.000Z","path":"2018/08/30/2018-08-30-Java/","text":"Spring MVC 与 SpringBoot 区别 Spring mvc 基于 Servlet 的一个 MVC 框架,Spring MVC提供了一种轻度耦合的方式来开发web应用。Spring MVC是Spring的一个模块，式一个web框架。通过Dispatcher Servlet, ModelAndView 和 View Resolver，开发web应用变得很容易。解决的问题领域是网站应用程序或者服务开发——URL路由、Session、模板引擎、静态Web资源等等 Spring Boot 是基于Spring4的条件注册的一套快速开发整合包。 JDK8新特性 Lambda表达式 Stream函数式操作流元素集合 接口新增：默认方法与静态方法 方法引用,与Lambda表达式联合使用 引入重复注解 类型注解 最新的Date/Time API (JSR 310) 新增base64加解密API 数组并行（parallel）操作 JVM的PermGen空间被移除：取代它的是Metaspace（JEP 122）元空间 JDK8 interface default 方法作用 在接口中，增加default方法， 是为了既有的成千上万的Java类库的类增加新的功能， 且不必对这些类重新进行设计。 需要注意一点就是如果实现多个接口时，每个接口都有相同的default方法需要重写该方法。 Spring 中 抽象类 与 接口区别，使用场景 接口能够多实现，而抽象类只能单独被继承，其本质就是，一个类能继承多个接口，而只能继承一个抽象类。 方法上，抽象类的方法可以用abstract 和public或者protect修饰。而接口默认为public abttact 修饰。 抽象类的方法可以有需要子类实现的抽象方法，也可以有具体的方法。而接口在老版本的jdk中，只能有抽象方法，但是Java8版本的接口中，接口可以带有默认方法。 属性上，抽象类可以用各种各样的修饰符修饰。而接口的属性是默认的public static final 抽象类中可以含有静态代码块和静态方法，而接口不能含有静态方法和静态代码块。 抽象类可以含有构造方法，接口不能含有构造方法。 设计层面上，抽象类表示的是子类“是不是”属于某一类的子类，接口则表示“有没有”特性“能不能”做这种事。如飞机和鸟都能飞，但是他们在设计上实现一个Fly接口，实现fly()方法。远比两个类继承飞行物抽象类好得多。因为，飞机和鸟有太多的属性不一样。 设计层面上，另外一点，抽象类可以是一个模板，因为可以自己带集体方法，所以要加一个实现类都能有的方法，直接在抽象类中写出并实现就好，接口在以前的版本则不行。新版本Java8才有默认方法。 既然说到Java 8 那么就来说明，Java8中的接口中的默认方法是可以被多重继承的。而抽象类不行。 另外，接口只能继承接口。而抽象类可以继承普通的类，也能继承接口和抽象类。 Spring 两大特性实现原理。IOC AOP 原理IOC IOC 另外一种说法叫DI（Dependency Injection），即依赖注入。它并不是一种技术实现，而是一种设计思想。 1）接口注入；2）Construct注入；3）Setter注入 技术：（dom4j解析xml配置文件，工厂设计模式（解耦合），反射） AOP 默认有实现类就是使用jdk代理(InvocationHandler是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码)，否则就使用cglib动态调用( 通过字节码技术动态创建子类实例) Java JMM 内存模型（可见性，有序性，一致性） synchronized实现底层缓存一直协议，有序性，一致性 volatile 数据可见性 （synchronizd,volatile都能禁用JDK指令重排—》（JVM可以对它们在不改变数据依赖关系的情况下进行任意排序以提高程序性能）） Mysql 聚合索引匹配规则 最左匹配原则并不是where后第一个条件一定是索引的第一列 只要where后用到了索引第一列就会用到索引 EXPLAIN SELECT * FROM student WHERE cid=1 AND NAME=’小冷’ –分析执行计划; Mysql like 查询是否使用索引 mysql在使用like查询的时候只有不以%开头的时候，才会使用到索引。 Redis 五种数据类型 字符串类型string 散列类型hash 列表类型（list） 集合类型（set） 有序集合类型 拓展思维 基于spring Boot 实现可插拔式系统搭建，示例（针对不同客户需求，不改动代码实现功能开闭。） 基于maven 区分功能模块开发，基于注解实现功能模块注册","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Zookeeper","date":"2018-08-27T14:58:00.000Z","path":"2018/08/27/2018-08-27-Zookeeper/","text":"zookeeper可以用于搭建高可用服务框架，主要先看以下几个应用场景： 1、master的选举基本思路和编码实现 2、数据的发布和订阅 3、软负载均衡 4、分布式队列 5、分布式锁 6、命名服务","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Spring Boot 整合Druid数据源","date":"2018-07-05T05:33:00.000Z","path":"2018/07/05/2018-07-05-Java/","text":"Spring Boot 整合Druid数据源12ERROR:Cannot determine embedded database driver class for database type NONE 1.原因是：springboot启动时会自动注入数据源和配置jpa 2.解决：在@SpringBootApplication中排除其注入 1@SpringBootApplication(exclude=&#123;DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class&#125;)","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"SpringBoot连接mySQL事务失效","date":"2018-07-05T05:33:00.000Z","path":"2018/07/05/2018-07-04-Java/","text":"SpringBoot中JPA事务失效的问题 在SpringBoot中使用jpa，表是通过对应的实体直接建立，默认情况下，表的引擎engine=MyISAM性能更好,但不提供事务支持，如果需要使用事务,需要将JPA建表的默认引擎修改为：InNoDB，直接修改配置文件，如下： application.xml1spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect 或者 123spring: jpa: database-platform: org.hibernate.dialect.MySQL5InnoDBDialect #InnoDB才能支持事务 然后在特定的方法上使用注解@Transactional//注意导入的包是org.springframework.transaction.annotation.Transactional 12@Transactionalpublic void insertTwo()&#123;&#125; 查看表引擎 1MYsql show CREATE table name;","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"linux 断开某个用户的终端连接","date":"2018-07-04T11:45:00.000Z","path":"2018/07/04/2018-07-04-linux/","text":"1. who 查看用户连接 2. 断开远程用户 命令：fuser -k /dev/pts/x，x为who下看到的这个用户的pts序号，比如本例中的pts/0,pts/1 fuser -k /dev/pts/0","tags":[{"name":"linux","slug":"linux","permalink":"//litten.me/tags/linux/"}]},{"title":"linux环境搭建","date":"2018-04-14T11:45:00.000Z","path":"2018/04/14/2018-04-14-linux/","text":"云主机基础环境搭建TOMCAT JDK vim编辑文件基本命令 i → Insert 模式，按 ESC 回到 Normal 模式. x → 删当前光标所在的一个字符。 p → 粘贴剪贴板 dd → 删除当前行，并把删除的行存到剪贴板里 :wq → 存盘 + 退出 (:w 存盘, :q 退出) （注：:w 后可以跟文件名） JDK运行环境搭建 在Oracle官网下载jdk压缩包。通过WinScp上传到服务器 通过PuTTY命令（tar -zxvf xxx.tar.gz）解压 vim /etc/profile 打开配置文件开启编辑 在最前面添加： 1234export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131 export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 执行立即生效：source /etc/profile 检查新安装的jdk：java -version TOMCAT运行环境搭建 在Oracle官网下载tomcat压缩包。通过WinScp上传到服务器 通过PuTTY命令（tar -zxvf xxx.tar.gz）解压 进入tomcat的bin目录: cd /mydata/apache-tomcat-7.0.85/bin 查看tomcat是否关闭(无信息证明关闭): ps -ef|grep java 查看进程号：ps -ef |grep tomcat kill -9 进程号 //关闭进程 启动tomcat： ./startup.sh","tags":[{"name":"linux","slug":"linux","permalink":"//litten.me/tags/linux/"}]},{"title":"【Java】集群session实现共享得几种方式","date":"2018-03-27T11:45:00.000Z","path":"2018/03/27/2018-03-27-Java/","text":"集群session共享？ ip_hash技术，nginx中可以配置。 Tomcat session传播，复制功能。 session存在缓存memcache或者redis中。","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"【Java】过滤器、拦截器","date":"2018-03-25T11:45:00.000Z","path":"2018/03/25/2018-03-25-Java/","text":"Filter（过滤器）与Interceptor（拦截器）和Spring AOP的区别？ Filter过滤器：拦截web访问url地址。 Interceptor拦截器：拦截以 .action结尾的url，拦截Action的访问。 Spring AOP拦截器：只能拦截Spring管理Bean的访问（业务层Service） ①拦截器是基于java的反射机制的，而过滤器是基于函数回调。 ②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 ③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 ④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 ⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 ⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 触发时机 过滤器和拦截器触发时机不一样: 过滤器是在请求进入容器后，但请求进入servlet之前进行预处理的。请求结束返回也是，是在servlet处理完后，返回给前端之前。 总结：过滤器包裹住servlet，servlet包裹住拦截器。 SpringMVC的机制是由同一个Servlet来分发请求给不同的Controller，其实这一步是在Servlet的service()方法中执行的。 所以过滤器、拦截器、service()方法，dispatc()方法的执行顺序应该是这样的 SpringMVC的机制是由同一个Servlet来分发请求给不同的Controller，其实这一步是在Servlet的service()方法中执行的。 拦截器是spring容器的，是spring支持的，","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"【Java】知识文献","date":"2018-02-26T11:45:00.000Z","path":"2018/02/26/2018-02-26-Java/","text":"操作系统中 heap 和 stack 的区别堆栈是两种数据结构。堆栈都是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。在单片机应用中，堆栈是个特殊的存储区，主要功能是暂时存放数据和地址，通常用来保护断点和现场。要点：堆，队列优先,先进先出（FIFO—first in first out） 。栈，先进后出(FILO—First-In/Last-Out) 什么是基于注解的切面实现一是减少重复，二是专注业务。 什么是 对象/关系 映射集成模块Spring通过提供ORM模块在JDBC的基础上支持对象关系映射工具。这样的支持使得Spring可以集成主流的ORM框架，包括Hibernate, JDO, 及iBATIS SQL Maps。Spring的事务管理可以同时支持以上某种框架和JDBC。 什么是 Java 的反射机制Java Reflaction in Action有这么一句话，可以解释。反射是运行中的程序检查自己和软件运行环境的能力，它可以根据它发现的进行改变。通俗的讲就是反射可以在运行时根据指定的类名获得类的信息。 什么是 ACIDACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易方的要求 BS与CS的联系与区别C/S是Client/Server的缩写。服务器通常采用高性能的PC、工作站或小型机，并采用大型数据库系统，如Oracle、Sybase、Informix或 SQL Server。客户端需要安装专用的客户端软件。B/S是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser），如Netscape Navigator或Internet Explorer，服务器安装Oracle、Sybase、Informix或 SQL Server等数据库。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现。浏览器通过Web Server 同数据库进行数据交互。C/S 与 B/S 区别： 硬件环境不同:C/S 一般建立在专用的网络上, 小范围里的网络环境, 局域网之间再通过专门服务器提供连接和数据交换服务.B/S 建立在广域网之上的, 不必是专门的网络硬件环境,例与电话上网, 租用设备. 信息自己管理. 有比C/S更强的适应范围, 一般只要有操作系统和浏览器就行 对安全要求不同C/S 一般面向相对固定的用户群, 对信息安全的控制能力很强. 一般高度机密的信息系统采用C/S 结构适宜. 可以通过B/S发布部分可公开信息.B/S 建立在广域网之上, 对安全的控制能力相对弱, 可能面向不可知的用户。 对程序架构不同C/S 程序可以更加注重流程, 可以对权限多层次校验, 对系统运行速度可以较少考虑.B/S 对安全以及访问速度的多重的考虑, 建立在需要更加优化的基础之上. 比C/S有更高的要求 B/S结构的程序架构是发展的趋势, 从MS的.Net系列的BizTalk 2000 Exchange 2000等, 全面支持网络的构件搭建的系统. SUN 和IBM推的JavaBean 构件技术等,使 B/S更加成熟. 软件重用不同C/S 程序可以不可避免的整体性考虑, 构件的重用性不如在B/S要求下的构件的重用性好.B/S 对的多重结构,要求构件相对独立的功能. 能够相对较好的重用.就入买来的餐桌可以再利用,而不是做在墙上的石头桌子 系统维护不同C/S 程序由于整体性, 必须整体考察, 处理出现的问题以及系统升级. 升级难. 可能是再做一个全新的系统B/S 构件组成,方面构件个别的更换,实现系统的无缝升级. 系统维护开销减到最小.用户从网上自己下载安装就可以实现升级. 处理问题不同C/S 程序可以处理用户面固定, 并且在相同区域, 安全要求高需求, 与操作系统相关. 应该都是相同的系统B/S 建立在广域网上, 面向不同的用户群, 分散地域, 这是C/S无法作到的. 与操作系统平台关系最小. 用户接口不同C/S 多是建立的Window平台上,表现方法有限,对程序员普遍要求较高B/S 建立在浏览器上, 有更加丰富和生动的表现方式与用户交流. 并且大部分难度减低,减低开发成本. 信息流不同C/S 程序一般是典型的中央集权的机械式处理, 交互性相对低B/S 信息流向可变化, B-B B-C B-G等信息、流向的变化, 更像交易中心。 Cookie 和 Session的区别cookie保存在客户端，session保存在服务器端，cookie目的可以跟踪会话，也可以保存用户喜好或者保存用户名密码session用来跟踪会话 fail-fast 与 fail-safe 机制有什么区别Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。 get 和 post请求的区别 GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。 GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。GET对数据长度有限制，当发送数据时， GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。 Interface 与 abstract 类的区别 都是上层的抽象层。 都不能被实例化 都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。 他们的区别如下：1) 在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。 一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。 Java语言中类的继承是单继承原因是：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。对于已经存在的继承树，可以方便的从类中抽象出新的接口，但是从类中抽象出新的抽象类就不那么容易了，因此接口更有利于软件系统的维护和重构。 IOC的优点是什么 IO 和 NIO的区别，NIO优点 Java 8 / Java 7 为我们提供了什么新功能 什么是竞态条件？ 举个例子说明。 JRE、JDK、JVM 及 JIT 之间有什么不同 MVC的各个部分都有那些技术来实现?如何实现? RPC 通信和 RMI 区别 什么是 Web Service（Web服务） JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 WEB容器主要有哪些功能? 并请列出一些常见的WEB容器名字。 一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制 简单说说你了解的类加载器。是否实现过类加载器 解释一下什么叫AOP（面向切面编程） 请简述 Servlet 的生命周期及其相关的方法 请简述一下 Ajax 的原理及实现步骤 简单描述Struts的主要功能 什么是 N 层架构 什么是CORBA？用途是什么 什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言” 什么是正则表达式？用途是什么？哪个包使用正则表达式来实现模式匹配 什么是懒加载（Lazy Loading） 什么是尾递归，为什么需要尾递归 什么是控制反转（Inversion of Control）与依赖注入（Dependency Injection）","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Java StringUtils 常用方法","date":"2018-02-03T02:50:00.000Z","path":"2018/02/03/2018-02-03-StringUtils/","text":"commons-lang3-3.1下载链接commons-lang3-3.1##基础类方法案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265package www.coolcat.club; import org.apache.commons.lang3.StringUtils; public class Demo &#123; public static void Test()&#123; //null 和 \"\"操作 //判断是否Null 或者 \"\" System.out.println(StringUtils.isEmpty(null)); System.out.println(StringUtils.isNotEmpty(null)); //判断是否null 或者 \"\" 去空格 System.out.println(StringUtils.isBlank(\" \")); System.out.println(StringUtils.isNotBlank(null)); //去空格.Null返回null System.out.println(StringUtils.trim(null)); //去空格，将Null和\"\" 转换为Null System.out.println(StringUtils.trimToNull(\"\")); //去空格，将NULL 和 \"\" 转换为\"\" System.out.println(StringUtils.trimToEmpty(null)); //可能是对特殊空格符号去除？？ System.out.println(StringUtils.strip(\"大家好 啊 \\t\")); //同上，将\"\"和null转换为Null System.out.println(StringUtils.stripToNull(\" \\t\")); //同上，将\"\"和null转换为\"\" System.out.println(StringUtils.stripToEmpty(null)); //将\"\"或者Null 转换为 \"\" System.out.println(StringUtils.defaultString(null)); //仅当字符串为Null时 转换为指定的字符串(二参数) System.out.println(StringUtils.defaultString(\"\", \"df\")); //当字符串为null或者\"\"时，转换为指定的字符串(二参数) System.out.println(StringUtils.defaultIfEmpty(null, \"sos\")); //去空格.去字符 //如果第二个参数为null去空格(否则去掉字符串2边一样的字符，到不一样为止) System.out.println(StringUtils.strip(\"fsfsdf\", \"f\")); //如果第二个参数为null只去前面空格(否则去掉字符串前面一样的字符，到不一样为止) System.out.println(StringUtils.stripStart(\"ddsuuu \", \"d\")); //如果第二个参数为null只去后面空格，(否则去掉字符串后面一样的字符，到不一样为止) System.out.println(StringUtils.stripEnd(\"dabads\", \"das\")); //对数组没个字符串进行去空格。 //ArrayToList(StringUtils.stripAll(new String[]&#123;\" 中华 \", \"民 国 \", \"共和 \"&#125;)); //如果第二个参数为null.对数组每个字符串进行去空格。(否则去掉数组每个元素开始和结尾一样的字符) //ArrayToList(StringUtils.stripAll(new String[]&#123;\" 中华 \", \"民 国\", \"国共和国\"&#125;, \"国\")); //查找,判断 //判断2个字符串是否相等相等,Null也相等 System.out.println(StringUtils.equals(null, null)); //不区分大小写比较 System.out.println(StringUtils.equalsIgnoreCase(\"abc\", \"ABc\")); //普通查找字符，如果一参数为null或者\"\"返回-1 System.out.println(StringUtils.indexOf(null, \"a\")); //从指定位置(三参数)开始查找，本例从第2个字符开始查找k字符 System.out.println(StringUtils.indexOf(\"akfekcd中华\", \"k\", 2)); //未发现不同之处 System.out.println(StringUtils.ordinalIndexOf(\"akfekcd中华\", \"k\", 2)); //查找,不区分大小写 System.out.println(StringUtils.indexOfIgnoreCase(\"adfs\", \"D\")); //从指定位置(三参数)开始查找,不区分大小写 System.out.println(StringUtils.indexOfIgnoreCase(\"adfs\", \"a\", 3)); //从后往前查找 System.out.println(StringUtils.lastIndexOf(\"adfas\", \"a\")); //未理解,此结果为2 System.out.println(StringUtils.lastIndexOf(\"d饿abasdafs我\", \"a\", 3)); //未解,此结果为-1 System.out.println(StringUtils.lastOrdinalIndexOf(\"yksdfdht\", \"f\", 2)); //从后往前查，不区分大小写 System.out.println(StringUtils.lastIndexOfIgnoreCase(\"sdffet\", \"E\")); //未解,此结果为1 System.out.println(StringUtils.lastIndexOfIgnoreCase(\"efefrfs看\", \"F\" , 2)); //检查是否查到，返回boolean,null返回假 System.out.println(StringUtils.contains(\"sdf\", \"dg\")); //检查是否查到，返回boolean,null返回假,不区分大小写 System.out.println(StringUtils.containsIgnoreCase(\"sdf\", \"D\")); //检查是否有含有空格,返回boolean System.out.println(StringUtils.containsWhitespace(\" d\")); //查询字符串跟数组任一元素相同的第一次相同的位置 System.out.println(StringUtils.indexOfAny(\"absfekf\", new String[]&#123;\"f\", \"b\"&#125;)); //查询字符串中指定字符串(参数二)出现的次数 System.out.println(StringUtils.indexOfAny(\"afefes\", \"e\")); //查找字符串中是否有字符数组中相同的字符，返回boolean System.out.println(StringUtils.containsAny(\"asfsd\", new char[]&#123;'k', 'e', 's'&#125;)); //未理解与lastIndexOf不同之处。是否查到，返回boolean System.out.println(StringUtils.containsAny(\"啡f咖啡\", \"咖\")); //未解 System.out.println(StringUtils.indexOfAnyBut(\"seefaff\", \"af\")); //判断字符串中所有字符，都是出自参数二中。 System.out.println(StringUtils.containsOnly(\"中华华\", \"华\")); //判断字符串中所有字符，都是出自参数二的数组中。 System.out.println(StringUtils.containsOnly(\"中华中\", new char[]&#123;'中', '华'&#125;)); //判断字符串中所有字符，都不在参数二中。 System.out.println(StringUtils.containsNone(\"中华华\", \"国\")); //判断字符串中所有字符，都不在参数二的数组中。 System.out.println(StringUtils.containsNone(\"中华中\", new char[]&#123;'中', '人'&#125;)); //从后往前查找字符串中与字符数组中相同的元素第一次出现的位置。本例为4 System.out.println(StringUtils.lastIndexOfAny(\"中国人民共和国\", new String[]&#123;\"国人\", \"共和\"&#125;)); //未发现与indexOfAny不同之处 查询字符串中指定字符串(参数二)出现的次数 System.out.println(StringUtils.countMatches(\"中国人民共和中国\", \"中国\")); //检查是否CharSequence的只包含Unicode的字母。空将返回false。一个空的CharSequence（长（）= 0）将返回true System.out.println(StringUtils.isAlpha(\"这是干什么的2\")); //检查是否只包含Unicode的CharSequence的字母和空格（''）。空将返回一个空的CharSequence假（长（）= 0）将返回true。 System.out.println(StringUtils.isAlphaSpace(\"NBA直播 \")); //检查是否只包含Unicode的CharSequence的字母或数字。空将返回false。一个空的CharSequence（长（）= 0）将返回true。 System.out.println(StringUtils.isAlphanumeric(\"NBA直播\")); //如果检查的Unicode CharSequence的只包含字母，数字或空格（''）。空将返回false。一个空的CharSequence（长（）= 0）将返回true。 System.out.println(StringUtils.isAlphanumericSpace(\"NBA直播\")); //检查是否只包含ASCII可CharSequence的字符。空将返回false。一个空的CharSequence（长（）= 0）将返回true。 System.out.println(StringUtils.isAsciiPrintable(\"NBA直播\")); //检查是否只包含数值。 System.out.println(StringUtils.isNumeric(\"NBA直播\")); //检查是否只包含数值或者空格 System.out.println(StringUtils.isNumericSpace(\"33 545\")); //检查是否只是空格或\"\"。 System.out.println(StringUtils.isWhitespace(\" \")); //检查是否全是英文小写。 System.out.println(StringUtils.isAllLowerCase(\"kjk33\")); //检查是否全是英文大写。 System.out.println(StringUtils.isAllUpperCase(\"KJKJ\")); //交集操作~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ //去掉参数2字符串中在参数一中开头部分共有的部分，结果为:人民共和加油 System.out.println(StringUtils.difference(\"中国加油\", \"中国人民共和加油\")); //统计2个字符串开始部分共有的字符个数 System.out.println(StringUtils.indexOfDifference(\"ww.taobao\", \"www.taobao.com\")); //统计数组中各个元素的字符串开始都一样的字符个数 System.out.println(StringUtils.indexOfDifference(new String[] &#123;\"中国加油\", \"中国共和\", \"中国人民\"&#125;)); //取数组每个元素共同的部分字符串 System.out.println(StringUtils.getCommonPrefix(new String[] &#123;\"中国加油\", \"中国共和\", \"中国人民\"&#125;)); //统计参数一中每个字符与参数二中每个字符不同部分的字符个数 System.out.println(StringUtils.getLevenshteinDistance(\"中国共和发国人民\", \"共和国\")); //判断开始部分是否与二参数相同 System.out.println(StringUtils.startsWith(\"中国共和国人民\", \"中国\")); //判断开始部分是否与二参数相同。不区分大小写 System.out.println(StringUtils.startsWithIgnoreCase(\"中国共和国人民\", \"中国\")); //判断字符串开始部分是否与数组中的某一元素相同 System.out.println(StringUtils.startsWithAny(\"abef\", new String[]&#123;\"ge\", \"af\", \"ab\"&#125;)); //判断结尾是否相同 System.out.println(StringUtils.endsWith(\"abcdef\", \"def\")); //判断结尾是否相同，不区分大小写 System.out.println(StringUtils.endsWithIgnoreCase(\"abcdef\", \"Def\")); //字符串截取 //截取指定位置的字符，null返回null.\"\"返回\"\" System.out.println(StringUtils.substring(\"国民党\", 2)); //截取指定区间的字符 System.out.println(StringUtils.substring(\"中国人民共和国\", 2, 4)); //从左截取指定长度的字符串 System.out.println(StringUtils.left(\"说点什么好呢\", 3)); //从右截取指定长度的字符串 System.out.println(StringUtils.right(\"说点什么好呢\", 3)); //从第几个开始截取，三参数表示截取的长度 System.out.println(StringUtils.mid(\"说点什么好呢\", 3, 2)); //截取到等于第二个参数的字符串为止 System.out.println(StringUtils.substringBefore(\"说点什么好呢\", \"好\")); //从左往右查到相等的字符开始，保留后边的，不包含等于的字符。本例：什么好呢 System.out.println(StringUtils.substringAfter(\"说点什么好呢\", \"点\")); //这个也是截取到相等的字符，但是是从右往左.本例结果：说点什么好 System.out.println(StringUtils.substringBeforeLast(\"说点什么好点呢\", \"点\")); //这个截取同上是从右往左。但是保留右边的字符 System.out.println(StringUtils.substringAfterLast(\"说点什么好点呢？\", \"点\")); //截取查找到第一次的位置，和第二次的位置中间的字符。如果没找到第二个返回null。本例结果:2010世界杯在 System.out.println(StringUtils.substringBetween(\"南非2010世界杯在南非，在南非\", \"南非\")); //返回参数二和参数三中间的字符串，返回数组形式 //ArrayToList(StringUtils.substringsBetween(\"[a][b][c]\", \"[\", \"]\")); //分割 //用空格分割成数组，null为null //ArrayToList(StringUtils.split(\"中华 人民 共和\")); //以指定字符分割成数组 //ArrayToList(StringUtils.split(\"中华 ,人民,共和\", \",\")); //以指定字符分割成数组，第三个参数表示分隔成数组的长度，如果为0全体分割 //ArrayToList(StringUtils.split(\"中华 ：人民：共和\", \"：\", 2)); //未发现不同的地方,指定字符分割成数组 //ArrayToList(StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\")); //未发现不同的地方,以指定字符分割成数组，第三个参数表示分隔成数组的长度 //ArrayToList(StringUtils.splitByWholeSeparator(\"ab-!-cd-!-ef\", \"-!-\", 2)); //分割，但\" \"不会被忽略算一个元素,二参数为null默认为空格分隔 //ArrayToList(StringUtils.splitByWholeSeparatorPreserveAllTokens(\" ab de fg \", null)); //同上，分割,\" \"不会被忽略算一个元素。第三个参数代表分割的数组长度。 //ArrayToList(StringUtils.splitByWholeSeparatorPreserveAllTokens(\"ab de fg\", null, 3)); //未发现不同地方,分割 //ArrayToList(StringUtils.splitPreserveAllTokens(\" ab de fg \")); //未发现不同地方,指定字符分割成数组 //ArrayToList(StringUtils.splitPreserveAllTokens(\" ab de fg \", null)); //未发现不同地方,以指定字符分割成数组，第三个参数表示分隔成数组的长度 //ArrayToList(StringUtils.splitPreserveAllTokens(\" ab de fg \", null, 2)); //以不同类型进行分隔 //ArrayToList(StringUtils.splitByCharacterType(\"AEkjKr i39:。中文\")); //未解 //ArrayToList(StringUtils.splitByCharacterTypeCamelCase(\"ASFSRules234\")); //拼接 //将数组转换为字符串形式 //System.out.println(StringUtils.concat(getArrayData())); //拼接时用参数一得字符相连接.注意null也用连接符连接了 //System.out.println(StringUtils.concatWith(\",\", getArrayData())); //也是拼接。未发现区别 //System.out.println(StringUtils.join(getArrayData())); //用连接符拼接，为发现区别 //System.out.println(StringUtils.join(getArrayData(), \":\")); //拼接指定数组下标的开始(三参数)和结束(四参数,不包含)的中间这些元素，用连接符连接 //System.out.println(StringUtils.join(getArrayData(), ':', 1, 3)); //用于集合连接字符串.用于集合 //System.out.println(StringUtils.join(getListData(), ':')); //移除，删除 //删除所有空格符 System.out.println(StringUtils.deleteWhitespace(\" s 中 你 4j\")); //移除开始部分的相同的字符 System.out.println(StringUtils.removeStart(\"www.baidu.com\", \"www.\")); //移除开始部分的相同的字符,不区分大小写 System.out.println(StringUtils.removeStartIgnoreCase(\"www.baidu.com\", \"WWW\")); //移除后面相同的部分 System.out.println(StringUtils.removeEnd(\"www.baidu.com\", \".com\")); //移除后面相同的部分，不区分大小写 System.out.println(StringUtils.removeEndIgnoreCase(\"www.baidu.com\", \".COM\")); //移除所有相同的部分 System.out.println(StringUtils.remove(\"www.baidu.com/baidu\", \"bai\")); //移除结尾字符为\"\\n\", \"\\r\", 或者 \"\\r\\n\". System.out.println(StringUtils.chomp(\"abcrabc\\r\")); //也是移除，未解。去结尾相同字符 System.out.println(StringUtils.chomp(\"baidu.com\", \"com\")); //去掉末尾最后一个字符.如果是\"\\n\", \"\\r\", 或者 \"\\r\\n\"也去除 System.out.println(StringUtils.chop(\"wwe.baidu\")); //替换 //替换指定的字符，只替换第一次出现的 System.out.println(StringUtils.replaceOnce(\"www.baidu.com/baidu\", \"baidu\", \"hao123\")); //替换所有出现过的字符 System.out.println(StringUtils.replace(\"www.baidu.com/baidu\", \"baidu\", \"hao123\")); //也是替换，最后一个参数表示替换几个 System.out.println(StringUtils.replace(\"www.baidu.com/baidu\", \"baidu\", \"hao123\", 1)); //这个有意识，二三参数对应的数组，查找二参数数组一样的值，替换三参数对应数组的值。本例:baidu替换为taobao。com替换为net System.out.println(StringUtils.replaceEach(\"www.baidu.com/baidu\", new String[]&#123;\"baidu\", \"com\"&#125;, new String[]&#123;\"taobao\", \"net\"&#125;)); //同上，未发现不同 System.out.println(StringUtils.replaceEachRepeatedly(\"www.baidu.com/baidu\", new String[]&#123;\"baidu\", \"com\"&#125;, new String[]&#123;\"taobao\", \"net\"&#125;)); //这个更好，不是数组对应，是字符串参数二和参数三对应替换.(二三参数不对应的话，自己看后果) System.out.println(StringUtils.replaceChars(\"www.baidu.com\", \"bdm\", \"qo\")); //替换指定开始(参数三)和结束(参数四)中间的所有字符 System.out.println(StringUtils.overlay(\"www.baidu.com\", \"hao123\", 4, 9)); //添加，增加 //复制参数一的字符串，参数二为复制的次数 System.out.println(StringUtils.repeat(\"ba\", 3)); //复制参数一的字符串，参数三为复制的次数。参数二为复制字符串中间的连接字符串 System.out.println(StringUtils.repeat(\"ab\", \"ou\", 3)); //如何字符串长度小于参数二的值，末尾加空格补全。(小于字符串长度不处理返回) System.out.println(StringUtils.rightPad(\"海川\", 4)); //字符串长度小于二参数，末尾用参数三补上，多于的截取(截取补上的字符串) System.out.println(StringUtils.rightPad(\"海川\", 4, \"河流啊\")); //同上在前面补全空格 System.out.println(StringUtils.leftPad(\"海川\", 4)); //字符串长度小于二参数，前面用参数三补上，多于的截取(截取补上的字符串) System.out.println(StringUtils.leftPad(\"海川\", 4, \"大家好\")); //字符串长度小于二参数。在两侧用空格平均补全（测试后面补空格优先） System.out.println(StringUtils.center(\"海川\", 3)); //字符串长度小于二参数。在两侧用三参数的字符串平均补全（测试后面补空格优先） System.out.println(StringUtils.center(\"海川\", 5, \"流\")); //只显示指定数量(二参数)的字符,后面以三个点补充(参数一截取+三个点=二参数) System.out.println(StringUtils.abbreviate(\"中华人民共和国\", 5)); //2头加点这个有点乱。本例结果: …ijklmno System.out.println(StringUtils.abbreviate(\"abcdefghijklmno\", 12, 10)); //保留指定长度，最后一个字符前加点.本例结果: ab.f System.out.println(StringUtils.abbreviateMiddle(\"abcdef\", \".\", 4)); //转换,刷选 //转换第一个字符为大写.如何第一个字符是大写原始返回 System.out.println(StringUtils.capitalize(\"Ddf\")); //转换第一个字符为大写.如何第一个字符是大写原始返回 System.out.println(StringUtils.uncapitalize(\"DTf\")); //反向转换，大写变小写，小写变大写 System.out.println(StringUtils.swapCase(\"I am Jiang, Hello\")); //将字符串倒序排列 System.out.println(StringUtils.reverse(\"中国人民\")); //根据特定字符(二参数)分隔进行反转 System.out.println(StringUtils.reverseDelimited(\"a.b.c\", '.')); &#125; &#125;","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"【2018】不断总结规律得旅途","date":"2018-01-27T11:45:00.000Z","path":"2018/01/27/2018-01-27-LiftTime/","text":"见贤思齐焉，见不贤而内自省也，2018 加油 1.除了备考使用错题本，在编程过程中，同样可以采用错题本的思想。2.记录在编码过程中常犯的错误，这样可以让自己有的放矢，3.而且举一反三，从而让自己的思维变的更严谨。","tags":[{"name":"生活","slug":"生活","permalink":"//litten.me/tags/生活/"}]},{"title":"【Tomcat】多实例项目配置","date":"2017-12-25T11:45:00.000Z","path":"2017/12/25/2017-12-25-Java/","text":"Tomcat 多实例部署,项目共享公用jar","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"linux命令介绍","date":"2017-10-14T16:00:00.000Z","path":"2017/10/15/2017-10-15-linux/","text":"使用linux快速复制 斜杠回到根目录 TAB上下键快捷选择","tags":[{"name":"linux","slug":"linux","permalink":"//litten.me/tags/linux/"}]},{"title":"Git Hub Commit","date":"2017-08-17T14:29:38.666Z","path":"2017/08/17/2017-08-17-commit/","text":"1、打开本地git命令窗口或者cmd命令窗口，cd到你存放项目的根目录下，并执行一下命令行： git clone 仓库地址(上面一步复制出来的地址)，如下图，是我复制我创建的仓库地址： 2、打开项目文件夹，会发现刚才在github里面新建的文件都存在本地了， 3、将要上传的文件拷贝到这个目录下，拷贝完成后，再执行下命令git status，看git是否获取到文件的更改，如图： 4、再执行命令git add –all,将所有文件都添加到仓库中，如果想添加某一个文件，则将后面的–all换成你要提交的文件名即可。 5、然后还需要将增加的文件commit到仓库里去，执行命令git commmit -m “注释语句”，如图： 6、此时还没完，还要将commit的代码push到远程分支，由于我们本地只有master分支，所以我们可以直接执行命令git push，如图： 会让你输入用户名和密码，你输入你github登录的用户名和密码即可。","tags":[{"name":"github","slug":"github","permalink":"//litten.me/tags/github/"}]},{"title":"Java ConcurrentHashMap 缓存","date":"2017-07-18T08:20:04.988Z","path":"2017/07/18/2017-07-18-cache/","text":"ConcurrentHashMap 缓存在项目实际开发中有时候固定不变的数据，大量请求数据库增加IO。我们就可以考虑缓存到内存中定时更新维护就行建议先看看：ConcurrentHashMap 基础类MonitorCache/** * Title: MonitorCache.java&lt;br /&gt; * Description: 实时监控缓存类&lt;br /&gt; * Copyright: Copyright (c) 2017&lt;br /&gt; */ public final class MonitorCache&lt;K, V&gt; { // 缓存Map private ConcurrentHashMap&lt;K, V&gt; cache; // 缓存计数器（用于判断缓存是否被占用） private int cacheCounter; // 更新时间（用于判断缓存中的数据是否更新） private Date updateDate; public MonitorCache() { this.cache = new ConcurrentHashMap&lt;K, V&gt;(); this.cacheCounter = 0; } public Date getUpdateDate() { return updateDate; } public void setUpdateDate(Date updateDate) { this.updateDate = updateDate; } /** * 开启缓存（计数器加1） */ public synchronized void open() { this.cacheCounter++; } /** * 关闭缓存（计数器减1） */ public synchronized void close() { this.cacheCounter = (this.cacheCounter - 1 &lt; 0) ? 0 : (this.cacheCounter - 1); } /** * 缓存当前是否空闲（未被占用） * * @return */ public boolean isFree() { return (this.cacheCounter == 0); } // 缓存访问校验 private void validate() { if (this.cacheCounter == 0) { throw new RuntimeException(&quot;缓存未打开时禁止访问&quot;); } } /** * 写入缓存数据 * * @param k * @param v */ public void put(K k, V v) { validate(); this.cache.put(k, v); } /** * 读取缓存数据 * * @param k * @return */ public V get(K k) { validate(); V v = this.cache.get(k); return v; } /** * 是否包含键值 * * @param key * @return */ public boolean containsKey(Object key) { validate(); return this.cache.containsKey(key); } /** * 读取所有键值 * * @return */ public Set&lt;K&gt; getAllKeys() { validate(); return this.cache.keySet(); } /** * 清空缓存 */ public void clearCache() { validate(); if (this.cache != null &amp;&amp; !this.cache.isEmpty()) { this.cache.clear(); } } /** * 缓存中存放的数据量 * * @return */ public int size() { validate(); return this.cache.size(); } } 分组类 MonitorCacheGroup/** * Title: MonitorCacheGroup.java&lt;br /&gt; * Description: 实时监控缓存集合类&lt;br /&gt; * Copyright: Copyright (c) 2017&lt;br /&gt; */ public final class MonitorCacheGroup&lt;K, V&gt; { private static final LogWrapper log = new LogWrapper(MonitorCacheGroup.class); // 缓存集合总量 private final static int CACHECOUNT = 5; // 缓存集合 private final List&lt;MonitorCache&lt;K, V&gt;&gt; cacheList; public MonitorCacheGroup() { cacheList = new ArrayList&lt;MonitorCache&lt;K, V&gt;&gt;(CACHECOUNT); MonitorCache&lt;K, V&gt; cache = null; for (int i = 0; i &lt; CACHECOUNT; i++) { cache = new MonitorCache&lt;K, V&gt;(); cacheList.add(cache); } } /** * 更新缓存 * * @param updatedCache */ public void updateCache(MonitorCache&lt;K, V&gt; updatedCache) { for (int i = 0; i &lt; CACHECOUNT; i++) { if (cacheList.get(i).isFree()) { updatedCache.setUpdateDate(new Date()); if (cacheList.get(i).isFree()) { cacheList.remove(i); cacheList.add(i, updatedCache); log.debug(&quot;当前更新缓存序号:&quot; + i); break; } } } } /** * 获取缓存（默认打开缓存） * * @return */ public MonitorCache&lt;K, V&gt; getCache() { int index = 0; // 要返回最近更新过的那份缓存 Date maxDate = cacheList.get(0).getUpdateDate(); for (int i = 1; i &lt; CACHECOUNT; i++) { MonitorCache&lt;K, V&gt; cache = cacheList.get(i); if (!ValidationUtil.isNullOrEmpty(cache) &amp;&amp; !ValidationUtil.isNullOrEmpty(cache.getUpdateDate())) { // 缓存没有数据 if (cache.getUpdateDate().compareTo(maxDate) &gt; 0) { maxDate = cacheList.get(i).getUpdateDate(); index = i; } } } log.debug(&quot;当前获取缓存序号:&quot; + index); cacheList.get(index).open(); return cacheList.get(index); } /** * 关闭缓存 * * @param cache */ public void closeCache(MonitorCache&lt;K, V&gt; cache) { if (cache != null) { cache.close(); } } } 使用缓存示例// 缓存容器 private volatile MonitorCacheGroup&lt;String, List&lt;Integer&gt;&gt; vehicleCacheGroup = new MonitorCacheGroup&lt;String, List&lt;Integer&gt;&gt;(); MonitorCache&lt;String, List&lt;Integer&gt;&gt; vCache = new MonitorCache&lt;String, List&lt;Integer&gt;&gt;(); //打开 vCache.open(); //更新 vehicleCacheGroup.updateCache(vCache); //获取 vCache.get(key);","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"yilia配置CNZZ","date":"2017-06-28T16:00:00.000Z","path":"2017/06/29/2017-06-29-2-yilia/","text":"使用CNZZ数据专家1、修改 themes\\yilia\\layout_partial\\footer.ejs 模板，把如下代码 &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot;&gt;Hexo&lt;/a&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt; 修改为： &lt;div id=&quot;footer-info&quot;&gt; &lt;div class=&quot;footer-left&quot;&gt; &amp;copy; &lt;%= date(new Date(), &apos;YYYY&apos;) %&gt; &lt;%= config.author || config.title %&gt; &lt;/div&gt; &lt;div class=&quot;footer-right&quot;&gt; &lt;-- 这里填写入CNZZ得js代码段 --&gt; Theme &lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot;&gt;Yilia&lt;/a&gt; by Litten &lt;/div&gt; &lt;/div&gt;","tags":[{"name":"yilia","slug":"yilia","permalink":"//litten.me/tags/yilia/"}]},{"title":"yilia配置多说评论","date":"2017-06-28T16:00:00.000Z","path":"2017/06/29/2017-06-29-1-yilia/","text":"使用畅言系统1、修改 themes\\yilia\\layout_partial\\article.ejs 模板，把如下代码 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;div id=&quot;disqus_thread&quot;&gt; 这里还有很多代码 &lt;/div&gt; &lt;/section&gt; &lt;% } %&gt; 修改为： &lt;% if (!index &amp;&amp; post.comments){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!--高速版，加载速度快，使用前需测试页面的兼容性--&gt; &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.title %&gt;&quot;&gt;&lt;/div&gt; &lt;script&gt; (function(){ var appid = &apos;你的APP ID&apos;, conf = &apos;你的APP KEY&apos;; var doc = document, s = doc.createElement(&apos;script&apos;), h = doc.getElementsByTagName(&apos;head&apos;)[0] || doc.head || doc.documentElement; s.type = &apos;text/javascript&apos;; s.charset = &apos;utf-8&apos;; s.src = &apos;http://assets.changyan.sohu.com/upload/changyan.js?conf=&apos;+ conf +&apos;&amp;appid=&apos; + appid; h.insertBefore(s,h.firstChild); window.SCS_NO_IFRAME = true; })() &lt;/script&gt; &lt;/section&gt; &lt;% } %&gt; 上面的APP ID和APP KEY是在畅言设置中得到。 这里需要注意一点的是：sid=”&lt;%= page.title %&gt;”&gt; 这样的话畅言就可以直接根据对应的文章来识别，使得文章有对应的评论，不会都乱在一起。 2、在每篇文章开头的 front-matter 中添加一句comments: true，然后回到博客根目录执行命令 hexo d -g ，重新生成博客并部署博客，然后刷新，任选一篇文章进入下拉，会发现评论功能可以使用了。 修改 BUG但是，这是你会发现一个 Bug，表情按钮点击不了，原因是被左侧的 div 层覆盖了，回到我们刚才改过的代码，找到 &lt;div id=”SOHUCS” 开头的一串代码。并做如下更改 &lt;div id=&quot;SOHUCS&quot; sid=&quot;&lt;%= page.title %&gt;&quot; style=&quot;padding: 0px 30px 0px 46px;&quot;&gt;&lt;/div&gt; 加入上面这一段样式代码，即可修复。","tags":[{"name":"yilia","slug":"yilia","permalink":"//litten.me/tags/yilia/"}]},{"title":"Javascript 页面飘窗","date":"2017-06-26T16:00:00.000Z","path":"2017/06/27/2017-06-27-8-Javascript/","text":"Javascript设置相对屏幕左右距离&lt;script type=&quot;text/javascript&quot;&gt; var obj; var x = 50,y = 60; var xin = true, yin = true; var step = 1; var delay = 30; function floatAD() { var L=T=0; var R= (document.documentElement.clientWidth || document.body.clientWidth)-obj.offsetWidth; var B = (document.documentElement.clientHeight || document.body.clientHeight)-obj.offsetHeight; obj.style.left = x + (document.documentElement.scrollLeft || document.body.scrollLeft) + &apos;px&apos;; obj.style.top = y + (document.documentElement.scrollTop || document.body.scrollTop) + &apos;px&apos;; x = x + step*(xin?1:-1); if (x &lt; L) { xin = true; x = L} if (x &gt; R){ xin = false; x = R} y = y + step*(yin?1:-1); if (y &lt; T) { yin = true; y = T } if (y &gt; B) { yin = false; y = B } } function loadTest(){ obj = document.getElementById(&quot;pc&quot;); if(obj!=null){ var itl= setInterval(&quot;floatAD()&quot;, delay); obj.onmouseover=function(){clearInterval(itl)}; obj.onmouseout=function(){itl=setInterval(&quot;floatAD()&quot;, delay)}; } } &lt;/script&gt; HTML设置加载onload=&quot;loadTest();&quot;//页面初始化加载 &lt;div id=&quot;pc&quot; style=&quot;Z-INDEX: 1000; POSITION: absolute&quot;&gt;&lt;A href=&quot;www.baidu.com&quot; target=&quot;_blank&quot;&gt;&lt;IMG src=&quot;images/cypc.png&quot; border=0 width=&quot;280&quot;/&gt;&lt;/A&gt;&lt;/div&gt;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"//litten.me/tags/Javascript/"}]},{"title":"druid连接池监控配置","date":"2017-06-26T16:00:00.000Z","path":"2017/06/27/2017-06-27-9-Mybatis/","text":"Maven添加jar包&lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;0.2.26&lt;/version&gt; &lt;/dependency&gt; 数据库连接池配置&lt;!-- druid driverClassName属性可以不用配置能自动识别，能自动从连接字符串中获取 --&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;*&quot; /&gt; &lt;property name=&quot;filters&quot; value=&quot;stat&quot; /&gt; &lt;property name=&quot;maxActive&quot; value=&quot;20&quot; /&gt; &lt;property name=&quot;initialSize&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;maxWait&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minIdle&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;60000&quot; /&gt; &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;300000&quot; /&gt; &lt;property name=&quot;validationQuery&quot; value=&quot;SELECT &apos;x&apos;&quot; /&gt; &lt;property name=&quot;testWhileIdle&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;testOnBorrow&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;testOnReturn&quot; value=&quot;false&quot; /&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;maxPoolPreparedStatementPerConnectionSize&quot; value=&quot;50&quot; /&gt; 配置Druid过滤器web.xml &lt;!-- 添加druid监控 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 允许清空统计数据 --&gt; &lt;param-name&gt;resetEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 用户名 --&gt; &lt;param-name&gt;loginUsername&lt;/param-name&gt; &lt;param-value&gt;druid&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!-- 密码 --&gt; &lt;param-name&gt;loginPassword&lt;/param-name&gt; &lt;param-value&gt;druid&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 添加Web应用等监控 session监控--&gt; &lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;profileEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalCookieName&lt;/param-name&gt; &lt;param-value&gt;USER_COOKIE&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalSessionName&lt;/param-name&gt; &lt;param-value&gt;USER_SESSION&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; druld配置spring监听过滤&lt;!-- druld配置spring 监听 --&gt; &lt;bean id=&quot;druid-stat-interceptor&quot; class=&quot;com.alibaba.druid.support.spring.stat.DruidStatInterceptor&quot; /&gt; &lt;bean id=&quot;druid-stat-pointcut&quot; class=&quot;org.springframework.aop.support.JdkRegexpMethodPointcut&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;patterns&quot;&gt; &lt;list&gt; &lt;value&gt;com.*.service.*&lt;/value&gt; &lt;value&gt;com.*.dao.*&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref=&quot;druid-stat-interceptor&quot; pointcut-ref=&quot;druid-stat-pointcut&quot; /&gt; &lt;/aop:config&gt; 访问地址http://ip:port/project/druid/index.html","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"//litten.me/tags/Mybatis/"}]},{"title":"GitHubBlog绑定域名","date":"2017-06-25T15:20:00.000Z","path":"2017/06/25/2017-06-25-6-Blog/","text":"GitHub Blog 绑定域名1、ping你的http://github.io域名，得到一个IP； 2、修改你的域名解析记录，添加一个A记录，用得到的IP； 3、登录http://github.com&gt;进入项目&gt;Settings&gt;Custom domain&gt;输入你的域名&gt;Save； 4、在博客source文件夹下新建CNAME文件，填入域名；","tags":[{"name":"github","slug":"github","permalink":"//litten.me/tags/github/"}]},{"title":"JAVA GC 简单总结","date":"2017-06-24T16:00:00.000Z","path":"2017/06/25/2017-06-25-7-Java/","text":"GC分代GC的英文全拼是Garbage Collection，意思是垃圾收集。 Java 将堆内存分为三代来管理： 年轻代 (Young Generation) 年老代 (Old Generation) 永久代 (Perm Generation) 年轻代：又分为Eden、From和To，其中From和To又统称为Survivor Spaces（幸存区）。年轻代大小可以由-Xmn来控制，也可以用-XX:SurvivorRatio来控制Eden和Survivor的比例，使用–XX:NewRatio来指定新生代和年老代的大小比例。 年老代：用来存放多次垃圾回收依然存活的对象。 永久代：来存放方法区。可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。 正常情况下，一个对象从创建到销毁，应该是从Eden，然后到Survivor Spaces（幸存区），再到Old Generation（年老代），最后在某次GC下消失。也可能一个对象直接在Eden里死掉，也可能一直在Old Generation（年老代）存活。 GC种类Java GC分为两类： Minar GC FULL GC Major GC Minar GC：从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC。 Major GC：是清理老年代。 FULL GC：是清理整个堆空间—包括年轻代和老年代。 GC的时候，会暂停全世界(stop-the-world)，意思是停止所有的应用线程，所以要避免不必要的GC已提高性能。 GC日志-XX:+PrintGCDetails打印日志详情。 -XX:+PrintGCTimeStamps打印时间戳。 -Xloggc输出GC日志到文件。","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Mybatis 执行速度监听","date":"2017-06-15T15:23:00.000Z","path":"2017/06/15/2017-06-15-4-Mybatis/","text":"Mybatis 添加执行sql时间监控在Mybatis配置文件中添加执行监控 &lt;!-- 数据库会话工厂 --&gt; &lt;bean id=&quot;sqlSessionFactoryDefault&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSourceDefault&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;bean id=&quot;sqlStatementInterceptor&quot; class=&quot;com.lan.console.common.SqlStatementInterceptor&quot;/&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 创建监听类:&nbsp;SqlStatementInterceptor @Intercepts(value = { @Signature(type = Executor.class, method = &quot;update&quot;, args = { MappedStatement.class, Object.class }), @Signature(type = Executor.class, method = &quot;query&quot;, args = { MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class }), @Signature(type = Executor.class, method = &quot;query&quot;, args = { MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class }) }) public class SqlStatementInterceptor implements Interceptor { private static Logger logger = LoggerFactory.getLogger(SqlStatementInterceptor.class); @SuppressWarnings(&quot;unused&quot;) private Properties properties; @Override public Object intercept(Invocation arg0) throws Throwable { MappedStatement mappedStatement = (MappedStatement) arg0.getArgs()[0]; String sqlId = mappedStatement.getId(); Object returnValue; long start = System.currentTimeMillis(); returnValue = arg0.proceed(); long end = System.currentTimeMillis(); long time = end - start; StringBuilder str = new StringBuilder(100); str.append(sqlId); str.append(&quot;: &quot;); str.append(&quot;cost time &quot;); str.append(time); str.append(&quot; ms.&quot;); String sqlInfo = str.toString(); logger.debug(sqlInfo); return returnValue; } @Override public Object plugin(Object arg0) { return Plugin.wrap(arg0, this); } @Override public void setProperties(Properties arg0) { this.properties = arg0; } }","tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"//litten.me/tags/Mybatis/"}]},{"title":"Java 字符串操作","date":"2017-05-25T15:23:00.000Z","path":"2017/05/25/2017-05-25-5-Java/","text":"Java 6以后就不再需要StringBuilder拼接字符串 Java基础篇一 在Java中，字符串对象是不可变的，意思是它一旦创建，你就无法再改变它。所以在我们拼接字符串的时候，创建了一个新的字符串，旧的被垃圾回收器所标记。如果我们处理上百万的字符串，然后，我们就会生成百万的额外字符串被垃圾回收器处理。 虚拟机底层在拼接字符串时执行了众多操作。拼接字符串最直接的点操作(dot operator)就是String#concat(String)操作 public String concat(String str) { int otherLen = str.length(); if (otherLen == 0) { return this; } int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true);}public static char[] copyOf(char[] original, int newLength) { char[] copy = new char[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;}void getChars(char dst[], int dstBegin) { System.arraycopy(value, 0, dst, dstBegin, value.length);} Sevlet绑定Spring bean SpringBeanAutowiringSupport.processInjectionBasedOnServletContext(this,cfg.getServletContext());//初始化Spring public static void processInjectionBasedOnServletContext(Object target, ServletContext servletContext) { Assert.notNull(target, “Target object must not be null”); WebApplicationContext cc = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext); AutowiredAnnotationBeanPostProcessor bpp = new AutowiredAnnotationBeanPostProcessor(); bpp.setBeanFactory(cc.getAutowireCapableBeanFactory());bpp.processInjection(target);}","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Java多线程面试问题","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-2-Java/","text":"1 . 进程和线程之间有什么不同？ 一个进程是一个独立(self contained)的运行环境，它可以被看作一个程序或者一个应用。而线程是在进程中执行的一个任务。Java运行环境是一个包含了不同的类和程序的单一进程。线程可以被称为轻量级进程。线程需要较少的资源来创建和驻留在进程中，并且可以共享进程中的资源。 2 . 多线程编程的好处是什么？ 在多线程程序中，多个线程被并发的执行以提高程序的效率，CPU不会因为某个线程需要等待资源而进入空闲状态。多个线程共享堆内存(heap memory)，因此创建多个线程去执行一些任务会比创建多个进程更好。举个例子，Servlets比CGI更好，是因为Servlets支持多线程而CGI不支持。 3 . 用户线程和守护线程有什么区别？ 当我们在Java程序中创建一个线程，它就被称为用户线程。一个守护线程是在后台执行并且不会阻止JVM终止的线程。当没有用户线程在运行的时候，JVM关闭程序并且退出。一个守护线程创建的子线程依然是守护线程。 4 . 我们如何创建一个线程？ 有两种创建线程的方法：一是实现Runnable接口，然后将它传递给Thread的构造函数，创建一个Thread对象；二是直接继承Thread类。若想了解更多可以阅读这篇关于如何在Java中创建线程的文章。 5 . 有哪些不同的线程生命周期？ 当我们在Java程序中新建一个线程时，它的状态是New。当我们调用线程的start()方法时，状态被改变为Runnable。线程调度器会为Runnable线程池中的线程分配CPU时间并且讲它们的状态改变为Running。其他的线程状态还有Waiting，Blocked 和Dead。读这篇文章可以了解更多关于线程生命周期的知识。 6 .可以直接调用Thread类的run()方法么？ 当然可以，但是如果我们调用了Thread的run()方法，它的行为就会和普通的方法一样，为了在新的线程中执行我们的代码，必须使用Thread.start()方法。 7 . 如何让正在运行的线程暂停一段时间？ 我们可以使用Thread类的Sleep()方法让线程暂停一段时间。需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。 8 . 你对线程优先级的理解是什么？ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。 9 . 什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？ 线程调度器是一个操作系统服务，它负责为Runnable状态的线程分配CPU时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。时间分片是指将可用的CPU时间分配给可用的Runnable线程的过程。分配CPU时间可以基于线程优先级或者线程等待的时间。线程调度并不受到Java虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。 10 . 在多线程中，什么是上下文切换(context-switching)？ 上下文切换是存储和恢复CPU状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。 11 . 你如何确保main()方法所在的线程是Java程序最后结束的线程？ 我们可以使用Thread类的joint()方法来确保所有程序创建的线程在main()方法退出前结束。这里有一篇文章关于Thread类的joint()方法。 12 .线程之间是如何通信的？ 当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。Object类中wait()\\notify()\\notifyAll()方法可以用于线程间通信关于资源的锁的状态。点击这里有更多关于线程wait, notify和notifyAll. 13 .为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？ Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是Object类的一部分，这样Java的每一个类都有用于线程间通信的基本方法 14 . 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？ 当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 15 . 为什么Thread类的sleep()和yield()方法是静态的？ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 16 .如何确保线程安全？ 在Java中可以有很多方法来保证线程安全——同步，使用原子类(atomic concurrent classes)，实现并发锁，使用volatile关键字，使用不变类和线程安全类。在线程安全教程中，你可以学到更多。 17 . volatile关键字在Java中有什么作用？ 当我们使用volatile关键字去修饰变量的时候，所以线程都会直接读取该变量并且不缓存它。这就确保了线程读取到的变量是同内存中是一致的。 18 . 同步方法和同步块，哪个是更好的选择？ 同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。 19 .如何创建守护线程？ 使用Thread类的setDaemon(true)方法可以将线程设置为守护线程，需要注意的是，需要在调用start()方法前调用这个方法，否则会抛出IllegalThreadStateException异常。 20 . 什么是ThreadLocal? ThreadLocal用于创建线程的本地变量，我们知道一个对象的所有线程会共享它的全局变量，所以这些变量不是线程安全的，我们可以使用同步技术。但是当我们不想使用同步的时候，我们可以选择ThreadLocal变量。 每个线程都会拥有他们自己的Thread变量，它们可以使用get()\\set()方法去获取他们的默认值或者在线程内部改变他们的值。ThreadLocal实例通常是希望它们同线程状态关联起来是private static属性。在ThreadLocal例子这篇文章中你可以看到一个关于ThreadLocal的小程序。 21 . 什么是Thread Group？为什么建议使用它？ ThreadGroup是一个类，它的目的是提供关于线程组的信息。 ThreadGroup API比较薄弱，它并没有比Thread提供了更多的功能。它有两个主要的功能：一是获取线程组中处于活跃状态线程的列表；二是设置为线程设置未捕获异常处理器(ncaught exception handler)。但在Java 1.5中Thread类也添加了setUncaughtExceptionHandler(UncaughtExceptionHandler eh) 方法，所以ThreadGroup是已经过时的，不建议继续使用。Java t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){ @Overridepublic void uncaughtException(Thread t, Throwable e) {System.out.println(“exception occured:”+e.getMessage());} });1 2 3 4 5 6 7 8t1.setUncaughtExceptionHandler(new UncaughtExceptionHandler(){ @Overridepublic void uncaughtException(Thread t, Throwable e) {System.out.println(“exception occured:”+e.getMessage());} }); 22 . 什么是Java线程转储(Thread Dump)，如何得到它？ 线程转储是一个JVM活动线程的列表，它对于分析系统瓶颈和死锁非常有用。有很多方法可以获取线程转储——使用Profiler，Kill -3命令，jstack工具等等。我更喜欢jstack工具，因为它容易使用并且是JDK自带的。由于它是一个基于终端的工具，所以我们可以编写一些脚本去定时的产生线程转储以待分析。读这篇文档可以了解更多关于产生线程转储的知识。 23 . 什么是死锁(Deadlock)？如何分析和避免死锁？ 死锁是指两个以上的线程永远阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。 分析死锁，我们需要查看Java应用程序的线程转储。我们需要找出那些状态为BLOCKED的线程和他们等待的资源。每个资源都有一个唯一的id，用这个id我们可以找出哪些线程已经拥有了它的对象锁。 避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法，阅读这篇文章去学习如何分析死锁。 24 . 什么是Java Timer类？如何创建一个有特定时间间隔的任务？ java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。 java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。 这里有关于java Timer的例子。 25 . 什么是线程池？如何创建一个Java线程池？ 一个线程池管理了一组工作线程，同时它还包括了一个用于放置等待执行的任务的队列。 java.util.concurrent.Executors提供了一个 java.util.concurrent.Executor接口的实现用于创建线程池。线程池例子展现了如何创建和使用线程池，或者阅读ScheduledThreadPoolExecutor例子，了解如何创建一个周期任务。 Java并发面试问题 1. 什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？ 原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。 int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。 为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。可以阅读这篇文章来了解Java的atomic类。 2. Java Concurrency API中的Lock接口(Lock interface)是什么？对比同步它有什么优势？ Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。 它的优势有： 可以使锁更公平 可以使线程在等待锁的时候响应中断 可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间 可以在不同的范围，以不同的顺序获取和释放锁 阅读更多关于锁的例子 3. 什么是Executors框架？ Executor框架同java.util.concurrent.Executor 接口在Java 5中被引入。Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。 无限制的创建线程会引起应用程序内存溢出。所以创建一个线程池是个更好的的解决方案，因为可以限制线程的数量并且可以回收再利用这些线程。利用Executors框架可以非常方便的创建一个线程池，阅读这篇文章可以了解如何使用Executor框架创建一个线程池。 4. 什么是阻塞队列？如何使用阻塞队列来实现生产者-消费者模型？ java.util.concurrent.BlockingQueue的特性是：当队列是空的时，从队列中获取或删除元素的操作将会被阻塞，或者当队列是满时，往队列里添加元素的操作会被阻塞。 阻塞队列不接受空值，当你尝试向队列中添加空值的时候，它会抛出NullPointerException。 阻塞队列的实现都是线程安全的，所有的查询方法都是原子的并且使用了内部锁或者其他形式的并发控制。 BlockingQueue 接口是java collections框架的一部分，它主要用于实现生产者-消费者问题。 阅读这篇文章了解如何使用阻塞队列实现生产者-消费者问题。 5. 什么是Callable和Future? Java 5在concurrency包中引入了java.util.concurrent.Callable 接口，它和Runnable接口很相似，但它可以返回一个对象或者抛出一个异常。 Callable接口使用泛型去定义它的返回类型。Executors类提供了一些有用的方法去在线程池中执行Callable内的任务。由于Callable任务是并行的，我们必须等待它返回的结果。java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它我们可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。 阅读这篇文章了解更多关于Callable，Future的例子。 6. 什么是FutureTask? FutureTask是Future的一个基础实现，我们可以将它同Executors使用处理异步任务。通常我们不需要使用FutureTask类，单当我们打算重写Future接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读Java FutureTask例子，学习如何使用它。 7.什么是并发容器的实现？ Java集合类都是快速失败的，这就意味着当集合被改变且一个线程在使用迭代器遍历集合的时候，迭代器的next()方法将抛出ConcurrentModificationException异常。 并发容器支持并发的遍历和并发的更新。 主要的类有ConcurrentHashMap, CopyOnWriteArrayList 和CopyOnWriteArraySet，阅读这篇文章了解如何避免ConcurrentModificationException。 8. Executors类是什么？ Executors为Executor，ExecutorService，ScheduledExecutorService，ThreadFactory和Callable类提供了一些工具方法。 Executors可以用于方便的创建线程池。","tags":[{"name":"Java","slug":"Java","permalink":"//litten.me/tags/Java/"}]},{"title":"Hello World","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-1-HelloWorld/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"//litten.me/tags/hexo/"}]},{"title":"2017五一醒悟","date":"2017-05-14T15:23:00.000Z","path":"2017/05/14/2017-05-14-3-LiftTime/","text":"这个五一回家休息三天，当一个人从繁忙中变得比较悠闲时，反而找不到北这也许是大家都有的经历吧，从今天开始我要每天进步一点为以后的生活增添资本，当我回忆自己上班已经4年余时，连我自己都不敢相信这就是事实，当我看到身边的同行的人都拥有他们自己想要的生活时，我都没自信自己这几年到底是干了神马也许我就是一个碌碌无为得人吧，但是在我心里面无时无刻的想要改变自己想自己变得优秀变得强大我想要的生活需要自己去争取,努力让每一天都有收获，为我以后幸福生活添砖加瓦,每天让自己写一篇技术博客 学习基础原理，学习源码精神，找机会自己在git上开源一个项目 坚持每天写一篇博客总结一天收获 学习身边优秀的技能，把好的习惯养成 坚持锻炼身体，有好的基础去学习，健康的资本","tags":[{"name":"生活","slug":"生活","permalink":"//litten.me/tags/生活/"}]}]